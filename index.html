<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATH BLASTER NEO</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { background:#000; overflow:hidden; font-family:'Courier New',monospace; }
        canvas { display:block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ═══════════════════════════════════════════════════════
// MATH BLASTER NEO – Cyberpunk Math Shooter (2025 edition)
// Controls: A/D or ←→ Move · Space/Mouse Shoot · P Pause
// ═══════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w, h;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const NEON = {
    pink: '#ff00aa', cyan: '#00ffff', green: '#00ff41',
    purple: '#bf00ff', yellow: '#ffff00', red: '#ff0044', white: '#ffffff'
};

let state = 'start'; // start, playing, paused, gameover
let score = 0, lives = 3, level = 1, combo = 0, highScore = localStorage.getItem('mbneo_hs')|0;
let player = {x: w/2, y: 0, size: 40, speed: 7};
let bullets = [], enemies = [], particles = [], stars = [];
let keys = {}, shootTimer = 0;
let currentQuestion = {}, spawnTimer = 0;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, dur=0.1, type='triangle') {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(0.2, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.start(); o.stop(audioCtx.currentTime + dur);
}

// Input
window.onkeydown = e => { keys[e.key.toLowerCase()] = true; if(e.key===' ')e.preventDefault(); if(e.key.toLowerCase()==='p') togglePause(); };
window.onkeyup = e => keys[e.key.toLowerCase()] = false;
canvas.onclick = () => { if(state==='start'||state==='gameover') startGame(); else if(state==='playing') shoot(); };

function togglePause(){ if(state==='playing') state = state==='paused'?'playing':'paused'; }

function newQuestion() {
    const ops = level<4 ? [['+']] : level<7 ? [['+','-']] : level<10 ? [['+','-','×']] : [['+','-','×','÷']];
    const op = ops[Math.random()*ops.length|0][0];
    let a,b,ans;
    switch(op){
        case '+': a=2+Math.random()*18|0; b=2+Math.random()*18|0; ans=a+b; break;
        case '-': a=5+Math.random()*20|0; b=1+Math.random()*a|0; ans=a-b; break;
        case '×': a=2+Math.random()*10|0; b=2+Math.random()*10|0; ans=a*b; break;
        case '÷': b=2+Math.random()*10|0; a=b*(2+Math.random()*10|0); ans=a/b; break;
    }
    currentQuestion = {text:`${a} ${op} ${b} = ?`, answer:ans};
}

function spawnEnemy() {
    const correct = Math.random()<0.25;
    let num = currentQuestion.answer;
    if(!correct){
        const offset = 1+level/3|0;
        num += -offset+Math.random()*offset*2|0;
        if(num===currentQuestion.answer) num+=1;
    }
    enemies.push({
        x: 100 + Math.random()*(w-200),
        y: -80,
        num, correct,
        speed: 1.5 + level*0.3,
        size: 50 + level*3,
        wave: Math.random()*Math.PI*2
    });
}

function shoot(){
    if(shootTimer>0) return;
    bullets.push({x:player.x, y:player.y-20, life:60});
    shootTimer = 9-level*0.5;
    beep(800,0.08,'square');
}

function explode(x,y,color){
    for(let i=0;i<25;i++){
        const a=Math.random()*Math.PI*2;
        const v=3+Math.random()*8;
        particles.push({
            x,y,
            vx:Math.cos(a)*v,
            vy:Math.sin(a)*v,
            life:30+Math.random()*30,
            color
        });
    }
}

// Stars background
for(let i=0;i<200;i++) stars.push({x:Math.random()*w,y:Math.random()*h,s:Math.random()*2+0.5,v:0.5+Math.random()});

function startGame(){
    state='playing'; score=0; lives=3; level=1; combo=0;
    bullets=[]; enemies=[]; particles=[];
    player.x = w/2; player.y = h-120;
    newQuestion();
    beep(400,0.6);
}

function gameOver(){
    state='gameover';
    if(score>highScore){
        highScore=score;
        localStorage.setItem('mbneo_hs',score);
    }
}

function update(){
    if(state==='playing'){
        // Player
        if(keys['a']||keys['arrowleft']) player.x-=player.speed;
        if(keys['d']||keys['arrowright']) player.x+=player.speed;
        player.x = Math.max(player.size, Math.min(w-player.size, player.x));
        player.y = h-120;

        // Shooting
        if(shootTimer>0) shootTimer--;
        if(keys[' ']) shoot();

        // Spawn
        spawnTimer++;
        if(spawnTimer>Math.max(30,90-level*6)){
            spawnEnemy();
            spawnTimer=0;
            newQuestion();
        }

        // Bullets
        bullets = bullets.filter(b=>{
            b.y-=12; b.life--;
            return b.y>-20 && b.life>0;
        });

        // Enemies
        enemies.forEach((e,i)=>{
            e.y += e.speed;
            e.x += Math.sin(e.wave + Date.now()*0.001)*2;
            if(e.y > h+100){
                enemies.splice(i,1);
                lives--;
                combo=0;
                beep(150,0.4,'sawtooth');
                if(lives<=0) gameOver();
            }
        });

        // Collision
        bullets.forEach((b,bi)=>{
            enemies.forEach((e,ei)=>{
                if(Math.hypot(b.x-e.x,b.y-e.y)<e.size/2){
                    bullets.splice(bi,1);
                    enemies.splice(ei,1);
                    explode(e.x,e.y,e.correct?NEON.pink:NEON.yellow);
                    if(e.correct){
                        score += 100*level*(combo+1);
                        combo++;
                        level += (enemies.length+bullets.length===0 && score>0 && score%1000<100)?1:0;
                        beep(600+level*50,0.2);
                    }else{
                        combo=0;
                        beep(200,0.3,'sawtooth');
                    }
                }
            });
        });

        // Particles
        particles = particles.filter(p=>{
            p.x+=p.vx; p.y+=p.vy; p.vy+=0.2;
            p.life--;
            return p.life>0;
        });

        // Stars
        stars.forEach(s=>{ s.y+=s.v; if(s.y>h) s.y=0; });
    }

    requestAnimationFrame(loop);
}

function draw(){
    // Background
    ctx.fillStyle='#000011';
    ctx.fillRect(0,0,w,h);

    // Stars
    ctx.fillStyle=NEON.green;
    stars.forEach(s=>{ ctx.globalAlpha=0.7; ctx.fillRect(s.x,s.y, s.s, s.s*4); });
    ctx.globalAlpha=1;

    if(state==='playing' || state==='paused'){
        // Question
        ctx.font='900 80px Courier New';
        ctx.fillStyle=NEON.cyan;
        ctx.shadowColor=NEON.cyan; ctx.shadowBlur=40;
        ctx.textAlign='center';
        ctx.fillText(currentQuestion.text, w/2, 100);
        ctx.font='900 120px Courier New';
        ctx.fillStyle=NEON.pink;
        ctx.shadowColor=NEON.pink; ctx.shadowBlur=60;
        ctx.fillText(currentQuestion.answer, w/2, 220);

        // Enemies
        enemies.forEach(e=>{
            ctx.shadowColor = e.correct?NEON.pink:NEON.green;
            ctx.shadowBlur=30;
            ctx.fillStyle = e.correct?NEON.pink:NEON.green;
            ctx.beginPath();
            ctx.arc(e.x,e.y,e.size/2,0,Math.PI*2);
            ctx.fill();
            ctx.fillStyle='#000';
            ctx.font='bold '+(e.size/2.5)+'px Courier New';
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(e.num,e.x,e.y);
        });

        // Player ship
        ctx.shadowColor=NEON.cyan; ctx.shadowBlur=50;
        ctx.fillStyle=NEON.cyan;
        ctx.save();
        ctx.translate(player.x,player.y);
        ctx.beginPath();
        ctx.moveTo(0,-player.size/2);
        ctx.lineTo(-player.size/2,player.size/2);
        ctx.lineTo(player.size/2,player.size/2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Bullets
        ctx.shadowColor=NEON.pink; ctx.shadowBlur=20;
        ctx.fillStyle=NEON.pink;
        bullets.forEach(b=>ctx.fillRect(b.x-4,b.y-15,8,30));

        // Particles
        particles.forEach(p=>{
            ctx.globalAlpha = p.life/60;
            ctx.shadowColor = ctx.fillStyle = p.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(p.x-4,p.y-4,8,8);
        });
        ctx.globalAlpha=1;

        // HUD
        ctx.shadowBlur=20;
        ctx.font='bold 36px Courier New';
        ctx.fillStyle=NEON.white;
        ctx.textAlign='left';
        ctx.fillText(`SCORE ${score.toLocaleString()}`,30,50);
        ctx.fillText(`LEVEL ${level}`,30,100);
        ctx.fillStyle=NEON.yellow;
        ctx.fillText(`COMBO ×${combo}`,30,150);

        // Lives
        for(let i=0;i<lives;i++){
            ctx.fillStyle=NEON.red;
            ctx.shadowColor=NEON.red;
            ctx.beginPath();
            ctx.arc(w-80-i*50,60,20,0,Math.PI*2);
            ctx.fill();
        }
    }

    // Menus
    if(state==='start' || state==='gameover'){
        ctx.fillStyle='rgba(0,0,20,0.8)';
        ctx.fillRect(0,0,w,h);

        ctx.shadowBlur=80;
        ctx.font='900 120px Courier New';
        ctx.fillStyle=NEON.pink;
        ctx.textAlign='center';
        ctx.fillText('MATH',w/2,h/2-100);
        ctx.fillStyle=NEON.cyan;
        ctx.fillText('BLASTER',w/2,h/2);
        ctx.fillStyle=NEON.purple;
        ctx.font='900 90px Courier New';
        ctx.fillText('NEO',w/2,h/2+100);

        if(state==='gameover'){
            ctx.font='bold 60px Courier New';
            ctx.fillStyle=NEON.red;
            ctx.fillText('GAME OVER',w/2,h/2+200);
            ctx.fillStyle=NEON.white;
            ctx.fillText(`FINAL SCORE: ${score.toLocaleString()}`,w/2,h/2+270);
            if(score===highScore) ctx.fillStyle=NEON.yellow, ctx.fillText('NEW HIGH SCORE!',w/2,h/2+330);
        }

        // Start button
        const btnY = state==='start'? h/2+300 : h/2+400;
        ctx.shadowColor=NEON.green; ctx.shadowBlur=50;
        ctx.fillStyle=NEON.green;
        ctx.fillRect(w/2-200,btnY,400,100);
        ctx.shadowBlur=0;
        ctx.fillStyle='#000';
        ctx.font='bold 60px Courier New';
        ctx.fillText(state==='start'?'START GAME':'PLAY AGAIN',w/2,btnY+65);
    }

    if(state==='paused'){
        ctx.fillStyle='rgba(0,0,30,0.9)';
        ctx.fillRect(0,0,w,h);
        ctx.shadowColor=NEON.yellow; ctx.shadowBlur=80;
        ctx.fillStyle=NEON.yellow;
        ctx.font='900 140px Courier New';
        ctx.textAlign='center';
        ctx.fillText('PAUSED',w/2,h/2);
    }

    ctx.shadowBlur=0;
}

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

newQuestion();
loop();
</script>
</body>
</html>
